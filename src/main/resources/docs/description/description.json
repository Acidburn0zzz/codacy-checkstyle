[ {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks in case statements"
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on block contents"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "exceptionVariableName",
    "description" : "The name of variable associated with exception"
  }, {
    "name" : "commentFormat",
    "description" : "The format of the first comment inside empty catch"
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a left curly brace ('{')"
  }, {
    "name" : "ignoreEnums",
    "description" : "If true, Check will ignore enums when left curly brace policy is EOL"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowSingleLineStatement",
    "description" : "allows single-line statements without braces"
  }, {
    "name" : "allowEmptyLoopBody",
    "description" : "allows loops with empty bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a right curly brace ('}')"
  }, {
    "name" : "shouldStartLine",
    "description" : "should we check if '}'\n            starts line."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "\n              the maximum allowed number of boolean operations in one\n              expression.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "whether to treat the whole switch block as a single decision point"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "methodMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              method.\n            "
  }, {
    "name" : "classMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              class.\n            "
  }, {
    "name" : "fileMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              file including all top level and nested classes.\n            "
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "\n              the maximum allowed number of boolean operations in one\n              expression.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "whether to treat the whole switch block as a single decision point"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "methodMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              method.\n            "
  }, {
    "name" : "classMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              class.\n            "
  }, {
    "name" : "fileMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              file including all top level and nested classes.\n            "
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "\n              the maximum allowed number of boolean operations in one\n              expression.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "whether to treat the whole switch block as a single decision point"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "methodMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              method.\n            "
  }, {
    "name" : "classMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              class.\n            "
  }, {
    "name" : "fileMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              file including all top level and nested classes.\n            "
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "\n              the maximum allowed number of boolean operations in one\n              expression.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "whether to treat the whole switch block as a single decision point"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "methodMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              method.\n            "
  }, {
    "name" : "classMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              class.\n            "
  }, {
    "name" : "fileMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              file including all top level and nested classes.\n            "
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks in case statements"
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on block contents"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "exceptionVariableName",
    "description" : "The name of variable associated with exception"
  }, {
    "name" : "commentFormat",
    "description" : "The format of the first comment inside empty catch"
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a left curly brace ('{')"
  }, {
    "name" : "ignoreEnums",
    "description" : "If true, Check will ignore enums when left curly brace policy is EOL"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowSingleLineStatement",
    "description" : "allows single-line statements without braces"
  }, {
    "name" : "allowEmptyLoopBody",
    "description" : "allows loops with empty bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a right curly brace ('}')"
  }, {
    "name" : "shouldStartLine",
    "description" : "should we check if '}'\n            starts line."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks in case statements"
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on block contents"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "exceptionVariableName",
    "description" : "The name of variable associated with exception"
  }, {
    "name" : "commentFormat",
    "description" : "The format of the first comment inside empty catch"
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a left curly brace ('{')"
  }, {
    "name" : "ignoreEnums",
    "description" : "If true, Check will ignore enums when left curly brace policy is EOL"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowSingleLineStatement",
    "description" : "allows single-line statements without braces"
  }, {
    "name" : "allowEmptyLoopBody",
    "description" : "allows loops with empty bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a right curly brace ('}')"
  }, {
    "name" : "shouldStartLine",
    "description" : "should we check if '}'\n            starts line."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "Header",
  "title" : "Header",
  "parameters" : [ {
    "name" : "header",
    "description" : "\n              the required header specified inline. Individual header lines\n              must be separated by the string \"\\n\" (even on platforms with a\n              different line separator), see examples below.\n            "
  }, {
    "name" : "headerFile",
    "description" : "name of the file containing the required header"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreLines",
    "description" : "line numbers to ignore"
  }, {
    "name" : "charset",
    "description" : "character encoding to use when reading the headerFile"
  } ]
}, {
  "patternId" : "RegexpHeader",
  "title" : "RegexpHeader",
  "parameters" : [ {
    "name" : "headerFile",
    "description" : "name of the file containing the required header"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "multiLines",
    "description" : "line numbers to repeat (zero or more times)"
  }, {
    "name" : "charset",
    "description" : "character encoding to use when reading the headerFile"
  }, {
    "name" : "header",
    "description" : "\n              the required header specified inline. Individual header lines\n              must be separated by the string \"\\n\" (even on platforms with a\n              different line separator). For header lines containing \"\\n\\n\"\n              checkstyle will forcefully expect an empty line to exist. See examples\n              below. Regular expressions must not span multiple lines.\n            "
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "\n              the maximum allowed number of boolean operations in one\n              expression.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "whether to treat the whole switch block as a single decision point"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "methodMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              method.\n            "
  }, {
    "name" : "classMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              class.\n            "
  }, {
    "name" : "fileMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              file including all top level and nested classes.\n            "
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks in case statements"
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on block contents"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "exceptionVariableName",
    "description" : "The name of variable associated with exception"
  }, {
    "name" : "commentFormat",
    "description" : "The format of the first comment inside empty catch"
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a left curly brace ('{')"
  }, {
    "name" : "ignoreEnums",
    "description" : "If true, Check will ignore enums when left curly brace policy is EOL"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowSingleLineStatement",
    "description" : "allows single-line statements without braces"
  }, {
    "name" : "allowEmptyLoopBody",
    "description" : "allows loops with empty bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a right curly brace ('}')"
  }, {
    "name" : "shouldStartLine",
    "description" : "should we check if '}'\n            starts line."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ModifierOrder",
  "title" : "ModifierOrder"
}, {
  "patternId" : "RedundantModifier",
  "title" : "RedundantModifier",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks in case statements"
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on block contents"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "exceptionVariableName",
    "description" : "The name of variable associated with exception"
  }, {
    "name" : "commentFormat",
    "description" : "The format of the first comment inside empty catch"
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a left curly brace ('{')"
  }, {
    "name" : "ignoreEnums",
    "description" : "If true, Check will ignore enums when left curly brace policy is EOL"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowSingleLineStatement",
    "description" : "allows single-line statements without braces"
  }, {
    "name" : "allowEmptyLoopBody",
    "description" : "allows loops with empty bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a right curly brace ('}')"
  }, {
    "name" : "shouldStartLine",
    "description" : "should we check if '}'\n            starts line."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "\n              the maximum allowed number of boolean operations in one\n              expression.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "whether to treat the whole switch block as a single decision point"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "methodMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              method.\n            "
  }, {
    "name" : "classMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              class.\n            "
  }, {
    "name" : "fileMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              file including all top level and nested classes.\n            "
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "ModifierOrder",
  "title" : "ModifierOrder"
}, {
  "patternId" : "RedundantModifier",
  "title" : "RedundantModifier",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Regexp",
  "title" : "Regexp",
  "parameters" : [ {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore matches found within comments."
  }, {
    "name" : "format",
    "description" : "pattern"
  }, {
    "name" : "errorLimit",
    "description" : "Controls the maximum number of errors before the check will abort."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n              if empty then the default (hard-coded) message is used."
  }, {
    "name" : "duplicateLimit",
    "description" : "Controls whether to check for duplicates of a required pattern,\n              any negative value means no checking for duplicates, any positive\n              value is used as the maximum number of allowed duplicates, if the\n              limit is exceeded errors will be logged."
  }, {
    "name" : "illegalPattern",
    "description" : "Controls whether the pattern is required or illegal."
  } ]
}, {
  "patternId" : "RegexpMultiline",
  "title" : "RegexpMultiline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpOnFilename",
  "title" : "RegexpOnFilename",
  "parameters" : [ {
    "name" : "ignoreFileNameExtensions",
    "description" : "Whether to ignore the file extension for the file name match."
  }, {
    "name" : "fileNamePattern",
    "description" : "Regular expression to match the file name against."
  }, {
    "name" : "folderPattern",
    "description" : "Regular expression to match the folder path against."
  }, {
    "name" : "fileExtensions",
    "description" : "File type extension of files to process. If this is specified, then\n            only files that match these types are examined with the other patterns."
  }, {
    "name" : "match",
    "description" : "Whether to look for a match or mis-match on the file name, if the\n            fileNamePattern is supplied, otherwise it is applied on the folderPattern."
  } ]
}, {
  "patternId" : "RegexpSingleline",
  "title" : "RegexpSingleline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpSinglelineJava",
  "title" : "RegexpSinglelineJava",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore text in comments when searching."
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "Header",
  "title" : "Header",
  "parameters" : [ {
    "name" : "header",
    "description" : "\n              the required header specified inline. Individual header lines\n              must be separated by the string \"\\n\" (even on platforms with a\n              different line separator), see examples below.\n            "
  }, {
    "name" : "headerFile",
    "description" : "name of the file containing the required header"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreLines",
    "description" : "line numbers to ignore"
  }, {
    "name" : "charset",
    "description" : "character encoding to use when reading the headerFile"
  } ]
}, {
  "patternId" : "RegexpHeader",
  "title" : "RegexpHeader",
  "parameters" : [ {
    "name" : "headerFile",
    "description" : "name of the file containing the required header"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "multiLines",
    "description" : "line numbers to repeat (zero or more times)"
  }, {
    "name" : "charset",
    "description" : "character encoding to use when reading the headerFile"
  }, {
    "name" : "header",
    "description" : "\n              the required header specified inline. Individual header lines\n              must be separated by the string \"\\n\" (even on platforms with a\n              different line separator). For header lines containing \"\\n\\n\"\n              checkstyle will forcefully expect an empty line to exist. See examples\n              below. Regular expressions must not span multiple lines.\n            "
  } ]
}, {
  "patternId" : "Regexp",
  "title" : "Regexp",
  "parameters" : [ {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore matches found within comments."
  }, {
    "name" : "format",
    "description" : "pattern"
  }, {
    "name" : "errorLimit",
    "description" : "Controls the maximum number of errors before the check will abort."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n              if empty then the default (hard-coded) message is used."
  }, {
    "name" : "duplicateLimit",
    "description" : "Controls whether to check for duplicates of a required pattern,\n              any negative value means no checking for duplicates, any positive\n              value is used as the maximum number of allowed duplicates, if the\n              limit is exceeded errors will be logged."
  }, {
    "name" : "illegalPattern",
    "description" : "Controls whether the pattern is required or illegal."
  } ]
}, {
  "patternId" : "RegexpMultiline",
  "title" : "RegexpMultiline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpOnFilename",
  "title" : "RegexpOnFilename",
  "parameters" : [ {
    "name" : "ignoreFileNameExtensions",
    "description" : "Whether to ignore the file extension for the file name match."
  }, {
    "name" : "fileNamePattern",
    "description" : "Regular expression to match the file name against."
  }, {
    "name" : "folderPattern",
    "description" : "Regular expression to match the folder path against."
  }, {
    "name" : "fileExtensions",
    "description" : "File type extension of files to process. If this is specified, then\n            only files that match these types are examined with the other patterns."
  }, {
    "name" : "match",
    "description" : "Whether to look for a match or mis-match on the file name, if the\n            fileNamePattern is supplied, otherwise it is applied on the folderPattern."
  } ]
}, {
  "patternId" : "RegexpSingleline",
  "title" : "RegexpSingleline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpSinglelineJava",
  "title" : "RegexpSinglelineJava",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore text in comments when searching."
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "Regexp",
  "title" : "Regexp",
  "parameters" : [ {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore matches found within comments."
  }, {
    "name" : "format",
    "description" : "pattern"
  }, {
    "name" : "errorLimit",
    "description" : "Controls the maximum number of errors before the check will abort."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n              if empty then the default (hard-coded) message is used."
  }, {
    "name" : "duplicateLimit",
    "description" : "Controls whether to check for duplicates of a required pattern,\n              any negative value means no checking for duplicates, any positive\n              value is used as the maximum number of allowed duplicates, if the\n              limit is exceeded errors will be logged."
  }, {
    "name" : "illegalPattern",
    "description" : "Controls whether the pattern is required or illegal."
  } ]
}, {
  "patternId" : "RegexpMultiline",
  "title" : "RegexpMultiline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpOnFilename",
  "title" : "RegexpOnFilename",
  "parameters" : [ {
    "name" : "ignoreFileNameExtensions",
    "description" : "Whether to ignore the file extension for the file name match."
  }, {
    "name" : "fileNamePattern",
    "description" : "Regular expression to match the file name against."
  }, {
    "name" : "folderPattern",
    "description" : "Regular expression to match the folder path against."
  }, {
    "name" : "fileExtensions",
    "description" : "File type extension of files to process. If this is specified, then\n            only files that match these types are examined with the other patterns."
  }, {
    "name" : "match",
    "description" : "Whether to look for a match or mis-match on the file name, if the\n            fileNamePattern is supplied, otherwise it is applied on the folderPattern."
  } ]
}, {
  "patternId" : "RegexpSingleline",
  "title" : "RegexpSingleline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpSinglelineJava",
  "title" : "RegexpSinglelineJava",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore text in comments when searching."
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "Regexp",
  "title" : "Regexp",
  "parameters" : [ {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore matches found within comments."
  }, {
    "name" : "format",
    "description" : "pattern"
  }, {
    "name" : "errorLimit",
    "description" : "Controls the maximum number of errors before the check will abort."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n              if empty then the default (hard-coded) message is used."
  }, {
    "name" : "duplicateLimit",
    "description" : "Controls whether to check for duplicates of a required pattern,\n              any negative value means no checking for duplicates, any positive\n              value is used as the maximum number of allowed duplicates, if the\n              limit is exceeded errors will be logged."
  }, {
    "name" : "illegalPattern",
    "description" : "Controls whether the pattern is required or illegal."
  } ]
}, {
  "patternId" : "RegexpMultiline",
  "title" : "RegexpMultiline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpOnFilename",
  "title" : "RegexpOnFilename",
  "parameters" : [ {
    "name" : "ignoreFileNameExtensions",
    "description" : "Whether to ignore the file extension for the file name match."
  }, {
    "name" : "fileNamePattern",
    "description" : "Regular expression to match the file name against."
  }, {
    "name" : "folderPattern",
    "description" : "Regular expression to match the folder path against."
  }, {
    "name" : "fileExtensions",
    "description" : "File type extension of files to process. If this is specified, then\n            only files that match these types are examined with the other patterns."
  }, {
    "name" : "match",
    "description" : "Whether to look for a match or mis-match on the file name, if the\n            fileNamePattern is supplied, otherwise it is applied on the folderPattern."
  } ]
}, {
  "patternId" : "RegexpSingleline",
  "title" : "RegexpSingleline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpSinglelineJava",
  "title" : "RegexpSinglelineJava",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore text in comments when searching."
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "Regexp",
  "title" : "Regexp",
  "parameters" : [ {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore matches found within comments."
  }, {
    "name" : "format",
    "description" : "pattern"
  }, {
    "name" : "errorLimit",
    "description" : "Controls the maximum number of errors before the check will abort."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n              if empty then the default (hard-coded) message is used."
  }, {
    "name" : "duplicateLimit",
    "description" : "Controls whether to check for duplicates of a required pattern,\n              any negative value means no checking for duplicates, any positive\n              value is used as the maximum number of allowed duplicates, if the\n              limit is exceeded errors will be logged."
  }, {
    "name" : "illegalPattern",
    "description" : "Controls whether the pattern is required or illegal."
  } ]
}, {
  "patternId" : "RegexpMultiline",
  "title" : "RegexpMultiline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpOnFilename",
  "title" : "RegexpOnFilename",
  "parameters" : [ {
    "name" : "ignoreFileNameExtensions",
    "description" : "Whether to ignore the file extension for the file name match."
  }, {
    "name" : "fileNamePattern",
    "description" : "Regular expression to match the file name against."
  }, {
    "name" : "folderPattern",
    "description" : "Regular expression to match the folder path against."
  }, {
    "name" : "fileExtensions",
    "description" : "File type extension of files to process. If this is specified, then\n            only files that match these types are examined with the other patterns."
  }, {
    "name" : "match",
    "description" : "Whether to look for a match or mis-match on the file name, if the\n            fileNamePattern is supplied, otherwise it is applied on the folderPattern."
  } ]
}, {
  "patternId" : "RegexpSingleline",
  "title" : "RegexpSingleline",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpSinglelineJava",
  "title" : "RegexpSinglelineJava",
  "parameters" : [ {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  }, {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore text in comments when searching."
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks in case statements"
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on block contents"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "exceptionVariableName",
    "description" : "The name of variable associated with exception"
  }, {
    "name" : "commentFormat",
    "description" : "The format of the first comment inside empty catch"
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a left curly brace ('{')"
  }, {
    "name" : "ignoreEnums",
    "description" : "If true, Check will ignore enums when left curly brace policy is EOL"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowSingleLineStatement",
    "description" : "allows single-line statements without braces"
  }, {
    "name" : "allowEmptyLoopBody",
    "description" : "allows loops with empty bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a right curly brace ('}')"
  }, {
    "name" : "shouldStartLine",
    "description" : "should we check if '}'\n            starts line."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "allowClassName",
    "description" : "\n              Controls whether to allow a method name to have the same\n              name as the residing class name.  This is not to be confused\n              with a constructor.  An easy mistake is to place a return\n              type on a constructor declaration which turns it into a\n              method. For example:\n              \nclass MyClass {\n    public void MyClass() {} //this is a method\n    public MyClass() {} //this is a constructor\n}\n              \n            "
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "\n              Allows to skip methods with Override annotation from validation. For example, the\n              following method's parameter will be skipped from validation, if\n              ignoreOverridden is true:\n              \n@Override\npublic boolean equals(Object o) {\n  return super.equals(o);\n}\n              \n            "
  }, {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  }, {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "\n              Allows for certain classes via a star notation to be\n              excluded such as java.lang.Math.* or specific static\n              members to be excluded like java.lang.System.out for a variable or\n              java.lang.Math.random for a\n              method.\n              \n              If you exclude a starred import on a class this automatically\n              excludes each member individually.\n              \n              For example: Excluding java.lang.Math.*. will allow the\n              import of each static member in the Math class\n              individually like java.lang.Math.PI.\n            "
  } ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  }, {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "\n              The location of the file containing the import control configuration.\n              It can be a regular file, URL or resource path. It will try loading\n              the path as a URL first, then as a file, and finally as a resource.\n            "
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  }, {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  }, {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "\n              File type extension to identify translation files. Setting\n              this property is typically only required if your\n              translation files are preprocessed and the original files\n              do not have the extension .properties\n            "
  }, {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "requiredTranslations",
    "description" : "\n              Allows to specify language codes of required translations which must exist in project.\n              Language code is composed of the lowercase, two-letter codes as defined by\n              ISO 639-1.\n              Default value is empty String Set which means that only the existence\n              of default translation is checked. Note, if you specify language codes (or just\n              one language code) of required translations the check will also check for\n              existence of default translation files in project.\n              ATTENTION: the check will perform the validation of ISO codes if the option\n              is used. So, if you specify, for example, \"mm\" for language code, TranslationCheck\n              will rise violation that the language code is incorrect.\n            "
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreSetter",
    "description" : "\n              Controls whether to ignore the parameter of a property setter\n              method, where the property setter method for field\n              \"xyz\" has name \"setXyz\", one parameter named\n              \"xyz\" and return type of void\n              ( default behavior) or class in which method is declared (only\n              if property setterCanReturnItsClass is set\n              to true).\n            "
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "\n              Used in conjunction with ignoreSetter property it\n              controls rule that recognizes method as a setter. By default\n              setter is a method with signature of type\n              \n                void setXyz(${someType} xyz)\n              \n              By setting this property (setterCanReturnItsClass)\n              to true we expand definition of setter to also\n              include returning class in which setter is defined. For example\n              \n                class Foo {\n                    int prop;\n                    Foo setProp(int prop) {\n                        this.prop = prop;\n                        return this;\n                    }\n                }\n              \n            "
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "\n              Token type names where duplicate strings are ignored even if they don't match\n              ignoredStringsRegexp. This allows you to exclude syntactical contexts like\n              annotations or static initializers from the check.\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for exception class names"
  }, {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  }, {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  }, {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "logLoadErrors",
    "description" : "This check may need to load exception classes mentioned in\n            the @throws tag to check whether they are RuntimeExceptions.\n            If loading the class fails, this property allows to control\n            checkstyle's error handling. If set to false a\n            classpath configuration problem is assumed and the TreeWalker\n            stops operating on the class completely.\n            If set to true (the default) , checkstyle assumes a\n            typo or refactoring problem in the\n            javadoc and logs the problem in the normal checkstyle report\n            (potentially masking a configuration error)."
  }, {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "\n              Whether to allow missing Javadoc on accessor methods for\n              properties (setters and getters). The setter and getter\n              methods must match exactly the structures below.\n\n              \npublic void setNumber(final int number)\n{\n    mNumber = number;\n}\n\npublic int getNumber()\n{\n    return mNumber;\n}\n\npublic boolean isSomething()\n{\n    return false;\n}\n              \n            "
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "suppressLoadErrors",
    "description" : "When logLoadErrors is set to true, the TreeWalker completely\n            processes a class and displays any problems with loading exceptions\n            as checkstyle violations.\n            When this property is set to true, the violations generated when\n            logLoadErrors is set true are suppressed from being reported as\n            violations in the checkstyle report.\n            "
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  }, {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  } ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "When this property is set to true check ignore cases\n            when JavaDoc is missing, but still warns when JavaDoc is\n            present but either @deprecated is missing from JavaDoc or\n            @deprecated is missing from the element.\n            "
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "\n              When this property is true this check will only check\n              classes, interfaces, etc. that do not contain the extends\n              or implements keyword or are not anonymous classes. This\n              means it only checks methods overridden from\n              java.lang.Object\n              Java 5 Compatibility mode severely limits this\n                check. It is recommended to only use it on Java 5 source \n            "
  } ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
} ]